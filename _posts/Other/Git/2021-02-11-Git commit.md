---
title:  "Git commit"
excerpt: "Git의 파일 변경 및 추적에 대해서 알아보자."
categories:
  - Git
tags:
  - 3
last_modified_at: 2021-02-11

toc: true
toc_label: "Table Of Contents"
toc_icon: "cog"
toc_sticky: true

use_math : true
---

# Git의 버전관리

- 깃이 코드 변화를 기록하는것을 commit 이라고 한다.
- 이렇게 변경시점을 저장해두면 잘못된 동작을 발견했을시에 특정 시점으로 되돌아갈 수 있다.
- 이렇게 관리하는것을 깃의 버전관리라고 한다.



# 파일 관리

- 깃이 없던 시절에는 파일을 변경하고 관리하기 위해 원본파일은 그대로 두고 원본의 복사본을 하나 만들어서 그것을 수정하였다.

  - 이 방식은 파일이 변경될때마다 파일이 복사되고, 그에따라 중복되는 내용도 같이 복사되기 째문에 용량을 많이 차지한다.
  - ex) 원본 -> 원본의 복사본1 -> 원본의 복사본2 ...

- 하지만 깃의 커밋은 새로 변경된 부분만 추출하여 처장한다.

  - 파일 이름을 변경하지 않아도 동일한 파일 이름 하나로 관리가 가능해진다.

  - 시간에 따라 변화되는 내용만 관리하게 되고, 코드가 변화된 시간 순서에 따라 영구적으로 보존
  - 이를 커밋이라고 한다.
  - 하나의 파일로 모든 이력을 처리하게되서 편리하다.
  - 깃은 이전 부모커밋을 기반으로 새로운 커밋을 만든다.
  - ex) 원본 -> 커밋1 -> 커밋2 -> ....



# git add

- 워킹 디렉토리에 있는 untracked 파일을 tracked 상태로 변경하기 위해 쓰는것이 git add 이다.
- tracked 되어있는 상태의 파일들을 commit 할 수 있기 때문에 꼭 git add 를 통해서 working -> stage 로 변환하는 작업이 필요하다.
- 파일 이름대신 .(점) 을 사용하면 전체 파일과 모든 폴더를 한번에 등록(tracked) 할 수 있다.
  - .(점) 은 현제 디렉토리를 의미한다.
- 이때에 빈 폴더는 스테이지 영역에 올릴 수 없다. 



# 파일의 추적상태

- git status 를 통해서 파일의 추적 상태를 확인할 수 있다.

![png](/assets/images/Git/2_1.PNG)

- 위와 같이 새로 만든 저장소 폴더에 ex.txt를 생성한되 status 를 해 보았다.
- 그 결과, 로컬에서 생성한 파일은 add 를 해주지 않아서 아직 untracked 의 상태이다.

![png](/assets/images/Git/2_2.PNG)

- 위와 같이 add ex.txt 를 통해서 stage 에 올리자 초록색으로 new file : ex.txt 가 표시되며 스테이지에 올려진것을 볼 수 있다.

# tracked 해제

- tracked 상태의 파일을 untracked 로 변경하는 과정이다.
- 실수로 다른 파일을 add 해서 stage 에 올렸을때에, 이 작업을 취소하기위해 쓴다.

## 커밋 안한 싱싱한 파일인 경우

- 커밋이 한번도 없었던(즉 원격 저장소에 올린적이없는) 파일을 실수로 add 한 경우 아래처럼 하면 된다.

- [git rm --cached 파일이름]
  - 스테이지 영역에서 등록된 파일을 삭제하게 된다.
  - tracked -> untracked 로 변환

![png](/assets/images/Git/2_3.PNG)

		- 위와 같이 tarcked 를 해제하자 status 에 아무것도 표시가 되지 않는것을 볼 수 있다.

## 커밋을 한번이라도 한 경우

- 커밋을 한 경우(즉 원격저장소에 그 파일이 올라가있는 경우) 위 과정처럼 git rm --cached 파일이름 을 쓰게되면 어떻게 될까?

  ![png](/assets/images/Git/2_4.PNG)

- 위 그림처럼 커밋후 파일을 [git rm --cached ] 으로 untracked 시키면 원본 파일도 delete  하려 한다.

  ![png](/assets/images/Git/2_5.PNG)

- 이대로 commit 을 진행하면 결국 위처럼 원래 repository 의 파일도 삭제가 되어버린다.

   ![png](/assets/images/Git/2_6.PNG)

- 위와 같이 [git reset 파일이름] 을 해 주어야 올바르게 tracked 를 해재할 수 있다.



# tracked 된 파일이름 변경

- 이는 git 이 충분히 똑똑해서 별도의 명령어로 처리하지 않아도 알아서 처리한다.

   ![png](/assets/images/Git/2_7.PNG)

- 위와 같이 add 되어있는 파일의 이름을 바꾸어도, 알아서 그 수정과 추적을 유지한다.



# git status

- 마지막 commit 이후 작업공간에서 변경이 일어난 모든 파일들을 나열해준다.
- 초록색 : 현재 추적하고있는 파일
- 빨간색 : 추적하지 않고있는 파일

# Head

- 깃에는 Head 라는 포인터 개념이 있다.
- Head 는 최종적인 커밋 작업의 위치를 가르킨다.(즉 부모 커밋)
- Head 는 커밋될때마다 한단계씩 이동하고, 마지막 커밋위치를 가르킨다.

![png](/assets/images/Git/2_8.PNG)



# 스냅샷

- 깃은 파일의 변화를 깃 저장소에 영구적으로 기록한다.
- 이떄 기록한다는것은 파일을 복사해서 관리하는것이 아니라, 파일에 변경된 내용을 찾아, 수정된 내용만 저장한다.
  - 변화된 부분만 찾아 사진을 찍는것과 비슷하다 해서 스냅샷이라 한다.
- 깃의 스냅샷은 Head 가 가르키는 커밋을 기반으로 사진을 찍는다. 그리고 이를 스테이지 영역과 비교해 새로운 커밋으로 기록. 



# git commit

- 수정된 파일 이력을 commit 하는 작업이다.
- 깃의 커밋은 head 와 스테이지 영역간 차이를 비교해서 새로운 객체를 생성하고, 이 객체를 깃 저장소에 기록한다.
- 변경된 파일 차이를 깃 저장소에 기록함과 동시에, 이를 구별할 수 있는 메시지를 같이 작성해야 한다. (이를 커밋 메세지라고 부름)
- git commit -m '쓰고싶은 메시지' 으로 메시지를 작성한다.



# 커밋 기록확인(git log)

- log 는 시간순으로 커밋 기록을 출력한다.(최신 기록부터)
- (note) 커밋 시간은 pc에서 설정한 시간정보를 바탕으로 기록하기 때문에 절대적이지 않다! 주의
- [git log] 를 통해 각 id 와 그 수정내역을 볼 수 있다.

![png](/assets/images/Git/2_9.PNG)

- [git log --pretty=short]

  

# 수정파일 되돌리기(git checkout)

- 수정한 파일을 수정 전 마지막 내용으로 쉽게 되돌릴 수 있다.

  ![png](/assets/images/Git/2_10.PNG)

- 위 파일은 원래 내용이 gogo 였다. 이를 내용을 바꾼 후 [git check out 파일이름] 을 실행하면

  ![png](/assets/images/Git/2_11.PNG)

- 되돌아온 모습을 볼 수 있다.