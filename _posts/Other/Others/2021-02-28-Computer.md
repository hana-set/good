---
title:  "컴퓨터 기초"
excerpt: "살~짝 훑어만 보자."
categories:
  - Others
tags:
  - 3
last_modified_at: 2021-02-28

toc: true
toc_label: "Table Of Contents"
toc_icon: "cog"
toc_sticky: true

use_math : true
---



# 컴퓨터의 구조

![png](/assets/images/{Others}/1_3.PNG)

- CPU(중앙연산처리)
  - 컴퓨터의 뇌 역활을 한다.
  - 뒤에 있는 작은 핀들을 통해 1초에 몇십억번씩 다음에 무엇을 해야하는지 물어본다.
  - 1초에 몇십억번씩 프로그래밍이 어떻게 되고 그다음 무었을 해야되는지 물어본다.

- 메인 메모리
  - 적은 양의 정보를 저장하는 장치이며, 속도는 매우 빠르지만 컴퓨터를 종료하면 사라지는 휘발성 메모리
  - CPU 에 명령을 전달한다.
  - 우리가 쓴 코드들이 업로드 된다.
- 세컨더리 메모리
  - 하드디스크처럼 영구적으로 보존되는 메모리
  - 여기에다가 코드를 저장하게 된다.

 

# 2진수

- 컴퓨터는 켜짐/꺼짐을 0/1 로 구성하여 오직 0과 1로만 데이터를 표시한다.

- 가 = 1000010101 처럼 단어나, 숫자들을 2진법으로 구성할 수 있다.
- binary digit 의 줄임말인 비트 는 0과 1 두가지 값만 가질 수 있는 측정 단위이다.

- 바이트(byte) : 여덟개의 비트가 모여 만들어진 것으로 256개의 정보를 만들어낼 수 있다.
- 아래 그림과 같이 단위에 따라서 저장할 수 있는 용량을 볼 수 있다.

![png](/assets/images/{Others}/1_0.PNG)

- 컴퓨터 과학에서는 16진수로 표현한다. 이는 0~9 와 A~F 까지의 알파벳을 더해 표현하는데, 16진수로 표현하면 훨씬 더 짧게 표현할 수 있기 때문이다.
  - 0F 31 5A 9F ... 의 구문을 본 적을 있지 않나? 이는 2개의 16진수, 즉 1 바이트의 표현을 두개의 값으로 나타낸 것이다
  - 16진수를 표현할때는 0x 를 앞에 붙이기로 하였다. 0x1A. ..... 

# Compiler

![png](/assets/images/{Others}/1_1.PNG)

- source code 는 파이썬 / c++ / 자바 같이 우리가 사용하는 프로그래밍 언어이다.
- machine code 는 컴퓨터가 이해하는 코드로 01010001.... 같이 2진수로 이루어져 있다.
- 소스코드를 입력으로 받아 머신코드로 번역/변환시켜주는것을 컴파일러라고 한다. 
- 컴파일러를 통해서 0과 1로 이루어진 출력을 해 준다.



# 컴파일링의 4단계

1. 전처리
   - 실질적인 컴파일이 일어나기 전에, 사용자가 설정한 내용을 실행

2. 컴파일
   - 전처리기가 전처리한 소스 코드를 생성하고 나면, 컴파일러가 C 코드를 어셈블리어라는 저수준 프로그래밍 언어로 컴파일한다.
   - 어셈블리어란 c 보다 연산의 종류는 훨씬 적지만 , 여러 연산들이 함께 사용되면 c 에서 할 수 있는 모든것들을 수행할 수 있다. C 코드를 어셈블리 코드로 변환시켜줌으로서 컴파일러는 컴퓨터가 이해할 수 있는 언어와 최대한 가까운 프로그램으로 만들어준다. 
3. 어셈블
   - 소스코드가 어셈블리 코드로 변환되면 어셈블 단계로, 어셈블리 코드를 오브젝트 코드로 변환시켜준다. 
   - 즉 컴퓨터가 이해할 수 있게 연속된 0,1 형태로 바꾸어 주는 작업이다. 
   - 이 단계는 어셈블러 라는 프로그램이 작업한다.
4. 링크
   - 프로그램이 여러개의 파일로 나누어져있는 경우, 하나의 오브젝트 파일로 합치는 작용을 한다.

# 메모리

- n 에다가 50을 넣게되면 메모리 어디에 있게 될까? 

  ![png](/assets/images/{Others}/1_1.PNG)

- 위 처럼 메모리 안에 (메모리도 ~기가의 바이트(즉 비트) 로 이루어져있음을 기억하자! 즉 램은 하나의 길고 큰 격자공간이다.) 50 이라는 메모리상의 주소를 받게 된다.

  - 즉 50이라는 값은, '램' 이라는 공간에 분양을 받게 된 것이다.
  - 이 그림에서 왜 4자리를 차지하고 있냐면, int 자료형은 int32 즉, 4바이트 만큼의 자리를 차지하기 때문이다. (int64 이면 8자리일 것이다.)

- 쓸데없이 메모리를 차지하고 있는 데이터를 제거하거나, 세밀한 작업이 필요 없는 자료는 float64 가 아니라 32 로 저장하는등의 방법을 통해 메모리를 절감할 수 있다.

# 컴퓨터의 한계

- 메모리 또는 RAM 은 모든 프로그램이 실행중 저장되는 공간이다.
- 컴퓨터가 여러 일들을 한꺼번에 할 때 저장되는 공간
- 하지만 이 공간은 유한하다.(내 노트북은 16기가의 RAM)

- 한 예시로 아주 간단한 1/10 을 하게되면 프로그램은 0.10000000000000002314123 가 나온다.
  - 컴퓨터는 계산 가능한 값 들중 1/10에 가~장 가까운 값을 저장하고 있다가 출력하는것이다.
  - 메모리 저장공간이 한정되어있기 때문! 모든 uncountable 한 실수들을 저장하기 위해서는 지구의 모든 RAM 을 가져와도 부족하다..!
  - 위와 같은 경우를 부동소수점의 부정확성이라고 한다.
- 또는 정수 오버플로우를 발생시킬수도 있다.
  - 2를 계속 곱하면서 늘려나가다 보면, 0이 나온다.
  - 이는 int 자료형에서는 32개의 비트가 다였기 때문이다.
  - ex) 보잉 787 에서 구동 후 248일이 지나면 모든 전력을 잃는 일이 있었다. 이는 248일을 1/100 초를 기준으로 계산하면 2의 32승이 나오는데, 즉 하드웨어를설계할 때 int값이 너무 커져서 오버플로우가 발생해버린다는것. 그래서 변수를 다시 0 으로 리셋하기 위해 주기적으로 시스템을 리셋해야 했다고 한다. 







